(defun swap-elt (source z newvalue)
  (cond
    ((stringp source)
     (string-append
       (subseq source 0 z)
       (create-string 1 newvalue)
       (subseq source (1+ z) (length source))))
    (t
      (let ((s source))
        (while s
          (if (zerop z)
            (set-car newvalue s))
          (setq z (1- z))
          (setq s (cdr s))
          )
        source))))
(defun swap-nthcdr (source z newvalue)
  (let ((s source))
    (while s
      (setq z (1- z))
      (if (zerop z)
        (set-cdr newvalue s))
      (setq s (cdr s))
      )
    source))
(defun swap-subseq (seq start end newvalue)
  (cond
    ((stringp seq)
     (string-append (subseq seq 0 start)
                    newvalue
                    (subseq seq end (length seq))))
    (t
      (let ((orig seq))
        (while seq
          (if (and (<= start 0) (> end 0) newvalue)
            (progn
              (set-car (car newvalue) seq)
              (setq newvalue (cdr newvalue))))
          (setq start (1- start))
          (setq end (1- end))
          (setq seq (cdr seq)))
        orig)
      )
    )
  )
(defun subst (newitem olditem L)
  (let ((result nil))
    (while L
      (if (equal olditem (car L))
        (setq result (cons newitem result))
        (setq result (cons (car L) result)))
      (setq L (cdr L)))
    (nreverse result)))
(let ((setf-table
        '((car . set-car)
          (cdr . set-cdr)
          (elt . set-elt)
          (dynamic . set-dynamic)
          (subseq . set-subseq)
          (setq . set-setq)
          (assoc . set-assoc))))
  (defmacro setf (expr newvalue)
    (if (symbolp expr)
      `(setq ,expr ,newvalue)
      (let* ((name (car expr))
             (pair (assoc name setf-table))
             (tmp nil)
             (setter
               (if pair
                 (cdr pair)
                 (progn
                   (setq tmp (convert (string-append "set-" (convert name <string>)) <symbol>))
                   (setq setf-table (cons (cons name tmp) setf-table))
                   tmp)))
             (arguments (cdr expr)))
        (cons setter (cons newvalue arguments))))))
(defmacro set-elt (newvalue seq z)
  `(setf ,seq (swap-elt ,seq ,z ,newvalue)))
(defmacro set-dynamic (newvalue name)
  `(defdynamic ,name ,newvalue))
(defmacro set-subseq (newvalue seq start end)
  `(setf ,seq (swap-subseq ,seq ,start ,end ,newvalue)))
(defmacro set-setq (newvalue name avlue)
  (let ((name (elt expr 1)) (value (elt expr 2)))
    `(progn (setq ,name ,value) (setf ,name ,newvalue))))
(defmacro set-assoc (newvalue key m)
  `(let ((_m ,m))
     (setf ,m (subst ,newvalue (assoc ,key _m) _m))))
; vim:set lispwords+=while,defglobal:
