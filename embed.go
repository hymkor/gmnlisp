package gmnlisp

// This code is generated by lsp2go.lsp
var embedFunctions = map[Symbol]Node{
	NewSymbol("when"):        &LispString{S: "(lambda-macro (test &rest args) `(if ,test (progn ,@args)))"},
	NewSymbol("unless"):      &LispString{S: "(lambda-macro (test &rest args) `(if ,test nil (progn ,@args)))"},
	NewSymbol("prog1"):       &LispString{S: "(lambda-macro (expr &rest args) (let ((x (gensym))) `(let ((,x ,expr)) (progn ,@args) ,x)))"},
	NewSymbol("prog2"):       &LispString{S: "(lambda-macro (expr1 expr2 &rest args) `(progn ,expr1 (prog1 ,expr2 ,@args)))"},
	NewSymbol("incf"):        &LispString{S: "(lambda-macro (place &rest args) (let ((delta (if args (car args) 1))) `(setf ,place (+ ,place ,delta))))"},
	NewSymbol("decf"):        &LispString{S: "(lambda-macro (place &rest args) (let ((delta (if args (car args) 1))) `(setf ,place (- ,place ,delta))))"},
	NewSymbol("swap-elt"):    &LispString{S: "(lambda (newvalue source z) (if (stringp source) (string-append (subseq source 0 z) (create-string 1 newvalue) (subseq source (1+ z) (length source))) (let ((s source)) (while s (if (zerop z) (set-car newvalue s)) (decf z) (setq s (cdr s))) source)))"},
	NewSymbol("swap-subseq"): &LispString{S: "(lambda (seq start end newvalue) (if (stringp seq) (string-append (subseq seq 0 start) newvalue (subseq seq end (length seq))) (let ((orig seq)) (while seq (if (and (<= start 0) (> end 0) newvalue) (progn (set-car (car newvalue) seq) (setq newvalue (cdr newvalue)))) (decf start) (decf end) (setq seq (cdr seq))) orig)))"},
	NewSymbol("setf"):        &LispString{S: "(let ((setf-table '((car . set-car) (cdr . set-cdr) (elt . set-elt) (dynamic . set-dynamic) (subseq . set-subseq) (setq . set-setq) (assoc . set-assoc) (aref . set-aref)))) (lambda-macro (expr newvalue) (if (symbolp expr) `(setq ,expr ,newvalue) (let* ((name (car expr)) (pair (assoc name setf-table)) (tmp nil) (setter (if pair (cdr pair) (progn (setq tmp (convert (string-append \"set-\" (convert name <string>)) <symbol>)) (setq setf-table (cons (cons name tmp) setf-table)) tmp))) (arguments (cdr expr))) (cons setter (cons newvalue arguments))))))"},
	NewSymbol("set-elt"):     &LispString{S: "(lambda-macro (newvalue seq &rest z) `(if (arrayp ,seq) (set-aref ,newvalue ,seq ,@z) (setf ,seq (swap-elt ,newvalue ,seq ,@z))))"},
	NewSymbol("set-dynamic"): &LispString{S: "(lambda-macro (newvalue name) `(defdynamic ,name ,newvalue))"},
	NewSymbol("set-subseq"):  &LispString{S: "(lambda-macro (newvalue seq start end) `(setf ,seq (swap-subseq ,seq ,start ,end ,newvalue)))"},
	NewSymbol("set-setq"):    &LispString{S: "(lambda-macro (newvalue name avlue) (let ((name (elt expr 1)) (value (elt expr 2))) `(progn (setq ,name ,value) (setf ,name ,newvalue))))"},
	NewSymbol("set-assoc"):   &LispString{S: "(lambda-macro (newvalue key m) (let ((L (gensym)) (K (gensym)) (tmp (gensym))) `(let* ((,L ,m) (,K ,key) (,tmp nil)) (while ,L (if (and (setq ,tmp (car ,L)) (consp ,tmp) (equal ,K (car ,tmp))) (set-car ,newvalue ,L)) (setq ,L (cdr ,L))))))"},
	NewSymbol("dolist"):      &LispString{S: "(lambda-macro (vars &rest body) (let ((var (car vars)) (values (elt vars 1)) (rest (gensym))) `(block nil (let ((,var nil) (,rest ,values)) (while ,rest (setq ,var (car ,rest)) (setq ,rest (cdr ,rest)) ,@body)))))"},
	NewSymbol("dotimes"):     &LispString{S: "(lambda-macro (vars &rest commands) (let ((var (car vars)) (count (elt vars 1)) (end (gensym))) `(let ((,var 0) (,end ,count)) (while (< ,var ,end) (progn ,@commands) (setq ,var (+ 1 ,var))))))"},
	NewSymbol("for"):         &LispString{S: "(lambda-macro (iters test-result &rest body) (let ((inits nil) (steps nil) (test (car test-result)) (result (elt test-result 1))) (while iters (let ((e (car iters))) (setq inits (cons (list (car e) (elt e 1)) inits)) (setq steps (append steps (list (car e) (elt e 2))))) (setq iters (cdr iters))) (setq steps (cons 'psetq steps)) `(let ,inits (while (not ,test) ,@body ,steps) ,result)))"},
	NewSymbol("nthcdr"):      &LispString{S: "(lambda (n x) (block nil (while (and (>= (decf n) 0) x) (unless (consp x) (return nil)) (setq x (cdr x))) x))"},
	NewSymbol("cddr"):        &LispString{S: "(lambda (x) (nthcdr 2 x))"},
	NewSymbol("cdddr"):       &LispString{S: "(lambda (x) (nthcdr 3 x))"},
	NewSymbol("cadr"):        &LispString{S: "(lambda (x) (elt x 1))"},
	NewSymbol("caddr"):       &LispString{S: "(lambda (x) (elt x 2))"},
	NewSymbol("cadddr"):      &LispString{S: "(lambda (x) (elt x 3))"},
	NewSymbol("first"):       &LispString{S: "(lambda (x) (car x))"},
	NewSymbol("second"):      &LispString{S: "(lambda (x) (elt x 1))"},
	NewSymbol("third"):       &LispString{S: "(lambda (x) (elt x 2))"},
	NewSymbol("rest"):        &LispString{S: "(lambda (x) (cdr x))"},
	NewSymbol("nth"):         &LispString{S: "(lambda (n x) (elt x n))"},
}
