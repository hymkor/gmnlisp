package gmnlisp

// This code is generated by lsp2go.lsp
var embedFunctions = map[Symbol]Node{
	NewSymbol("incf"):        &LispString{S: `(lambda-macro (place &rest args) (let ((delta (if args (car args) 1))) (list 'setf place (list '+ place delta))))`},
	NewSymbol("decf"):        &LispString{S: `(lambda-macro (place &rest args) (let ((delta (if args (car args) 1))) (list 'setf place (list '- place delta))))`},
	NewSymbol("swap-elt"):    &LispString{S: `(lambda (source z newvalue) (if (stringp source) (string-append (subseq source 0 z) (create-string 1 newvalue) (subseq source (1+ z) (length source))) (let ((s source)) (while s (if (zerop z) (set-car newvalue s)) (decf z) (setq s (cdr s))) source)))`},
	NewSymbol("swap-subseq"): &LispString{S: `(lambda (seq start end newvalue) (if (stringp seq) (string-append (subseq seq 0 start) newvalue (subseq seq end (length seq))) (let ((orig seq)) (while seq (if (and (<= start 0) (> end 0) newvalue) (progn (set-car (car newvalue) seq) (setq newvalue (cdr newvalue)))) (decf start) (decf end) (setq seq (cdr seq))) orig)))`},
	NewSymbol("setf"):        &LispString{S: `(let ((setf-table '((car . set-car) (cdr . set-cdr) (elt . set-elt) (dynamic . set-dynamic) (subseq . set-subseq) (setq . set-setq) (assoc . set-assoc)))) (lambda-macro (expr newvalue) (if (symbolp expr) (list 'setq expr newvalue) (let* ((name (car expr)) (pair (assoc name setf-table)) (tmp nil) (setter (if pair (cdr pair) (progn (setq tmp (convert (string-append "set-" (convert name <string>)) <symbol>)) (setq setf-table (cons (cons name tmp) setf-table)) tmp))) (arguments (cdr expr))) (cons setter (cons newvalue arguments))))))`},
	NewSymbol("set-elt"):     &LispString{S: `(lambda-macro (newvalue seq z) (list 'setf seq (list 'swap-elt seq z newvalue)))`},
	NewSymbol("set-dynamic"): &LispString{S: `(lambda-macro (newvalue name) (list 'defdynamic name newvalue))`},
	NewSymbol("set-subseq"):  &LispString{S: `(lambda-macro (newvalue seq start end) (list 'setf seq (list 'swap-subseq seq start end newvalue)))`},
	NewSymbol("set-setq"):    &LispString{S: `(lambda-macro (newvalue name avlue) (let ((name (elt expr 1)) (value (elt expr 2))) (list 'progn (list 'setq name value) (list 'setf name newvalue))))`},
	NewSymbol("set-assoc"):   &LispString{S: `(lambda-macro (newvalue key m) (let ((L (gensym)) (K (gensym)) (tmp (gensym))) (list 'let* (list (list L m) (list K key) (list tmp (quote nil))) (list 'while L (list 'if (list 'and (list 'setq tmp (list 'car L)) (list 'consp tmp) (list 'equal K (list 'car tmp))) (list 'set-car newvalue L)) (list 'setq L (list 'cdr L))))))`},
	NewSymbol("dolist"):      &LispString{S: `(lambda-macro (vars &rest body) (let ((var (car vars)) (values (elt vars 1)) (rest (gensym))) (list 'block (quote nil) (list 'let (list (list var (quote nil)) (list rest values)) (list 'while rest (list 'setq var (list 'car rest)) (list 'setq rest (list 'cdr rest)) @body)))))`},
	NewSymbol("dotimes"):     &LispString{S: `(lambda-macro (vars &rest commands) (let ((var (car vars)) (count (elt vars 1)) (end (gensym))) (list 'let (list (list var '0) (list end count)) (list 'while (list '< var end) (list 'progn @commands) (list 'setq var (list '+ '1 var))))))`},
}
