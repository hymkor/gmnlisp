package gmnlisp

// This code is generated by lsp2go.lsp

// NewSymbol("incf"): embed_incf,
var embed_incf = &LispString{S: `(lambda-macro (s) (list 'setq s (list '+ s '1)))`}

// NewSymbol("decf"): embed_decf,
var embed_decf = &LispString{S: `(lambda-macro (s) (list 'setq s (list '- s '1)))`}

// NewSymbol("swap-elt"): embed_swap_elt,
var embed_swap_elt = &LispString{S: `(lambda (source z newvalue) (if (stringp source) (string-append (subseq source 0 z) (create-string 1 newvalue) (subseq source (1+ z) (length source))) (let ((s source)) (while s (if (zerop z) (set-car newvalue s)) (decf z) (setq s (cdr s))) source)))`}

// NewSymbol("swap-subseq"): embed_swap_subseq,
var embed_swap_subseq = &LispString{S: `(lambda (seq start end newvalue) (if (stringp seq) (string-append (subseq seq 0 start) newvalue (subseq seq end (length seq))) (let ((orig seq)) (while seq (if (and (<= start 0) (> end 0) newvalue) (progn (set-car (car newvalue) seq) (setq newvalue (cdr newvalue)))) (decf start) (decf end) (setq seq (cdr seq))) orig)))`}

// NewSymbol("setf"): embed_setf,
var embed_setf = &LispString{S: `(let ((setf-table '((car . set-car) (cdr . set-cdr) (elt . set-elt) (dynamic . set-dynamic) (subseq . set-subseq) (setq . set-setq) (assoc . set-assoc)))) (lambda-macro (expr newvalue) (if (symbolp expr) (list 'setq expr newvalue) (let* ((name (car expr)) (pair (assoc name setf-table)) (tmp nil) (setter (if pair (cdr pair) (progn (setq tmp (convert (string-append "set-" (convert name <string>)) <symbol>)) (setq setf-table (cons (cons name tmp) setf-table)) tmp))) (arguments (cdr expr))) (cons setter (cons newvalue arguments))))))`}

// NewSymbol("set-elt"): embed_set_elt,
var embed_set_elt = &LispString{S: `(lambda-macro (newvalue seq z) (list 'setf seq (list 'swap-elt seq z newvalue)))`}

// NewSymbol("set-dynamic"): embed_set_dynamic,
var embed_set_dynamic = &LispString{S: `(lambda-macro (newvalue name) (list 'defdynamic name newvalue))`}

// NewSymbol("set-subseq"): embed_set_subseq,
var embed_set_subseq = &LispString{S: `(lambda-macro (newvalue seq start end) (list 'setf seq (list 'swap-subseq seq start end newvalue)))`}

// NewSymbol("set-setq"): embed_set_setq,
var embed_set_setq = &LispString{S: `(lambda-macro (newvalue name avlue) (let ((name (elt expr 1)) (value (elt expr 2))) (list 'progn (list 'setq name value) (list 'setf name newvalue))))`}

// NewSymbol("set-assoc"): embed_set_assoc,
var embed_set_assoc = &LispString{S: `(lambda-macro (newvalue key m) (list 'let* (list (list 'L m) (list 'K key) (list 'tmp (quote nil))) (list 'while 'L (list 'if (list 'and (list 'setq 'tmp (list 'car 'L)) (list 'consp 'tmp) (list 'equal 'K (list 'car 'tmp))) (list 'set-car newvalue 'L)) (list 'setq 'L (list 'cdr 'L)))))`}
