(defun to-safe (s)
  (let ((index nil))
    (while (and s (setq index (string-index "-" s)))
      (setq s (string-append (subseq s 0 index)
                             "_"
                             (subseq s (+ index 1) (length s))))
      )
    s))
(defun defun2lambda (node)
  (if (consp node)
    (case (car node)
      (('defun)
       (set-car 'lambda node)
       (let ((name (elt node 1)))
         (set-cdr (cdr (cdr node)) node)
         (convert name <string>))
       )
      (('defmacro)
       (set-car 'lambda-macro node)
       (let ((name (elt node 1)))
         (set-cdr (cdr (cdr node)) node)
         (convert name <string>))
       )
      (t
        (or (defun2lambda (car node))
            (defun2lambda (cdr node))))
      )
    )
  )

(let ((packagename (car *posix-argv*))
      (arguments (cdr *posix-argv*)))
  (format t "package ~a~%" packagename)
  (or (equal packagename "gmnlisp")
      (format t "~%import . \"github.com/hymkor/gmnlisp\""))
  (format t "~%// This code is generated by lsp2go.lsp")
  (while arguments
    (format t " ~a" (car arguments))
    (setq arguments (cdr arguments))
    )
  )
(format t "~%")
(format t "var embedFunctions = map[Symbol]Node{~%")
(let ((node nil)(name nil)(funcs nil)(max 0))
  (while (setq node (read (standard-input) nil nil))
    (if (setq name (defun2lambda node))
      (progn
        (setq funcs (cons (cons name node) funcs))
        (let ((L (length name)))
          (if (> L max)
            (setq max L)))
        )
      )
    )
  (setq funcs (nreverse funcs))
  (while funcs
    (setq name (car (car funcs)))
    (setq node (cdr (car funcs)))
    (setq funcs (cdr funcs))

    (format t "~aNewSymbol(~s):~a &LispString{S: `~s`},~%"
            #\tab
            name
            (create-string (- max (length name)) #\space)
            node)
    )
  )
(format t "}~%")
; vim:set lispwords+=while:
